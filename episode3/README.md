# Episode 3

## The Premise

In this episode we continue from Episode 2 and dig deeper into the code generated by `rustc` for loops and compare that code with the code generated by `g++` for a similar loops in C++.

In particular, we look at the code generated by `rust` for the loop in the following program:

```
use volatile::Volatile;

fn main() {
    let mut j = 0;
    let mut v = Volatile::new(&mut j);

    for _ in 0..1000000000 {
        v.write(v.read() + 1);
    }
}
```

and compare that with the code generated by `g++` for the following program:
```
#include <iostream>
#include <numeric>
#include <vector>

int main() {
	volatile int j = 0;
	// This is not the modern way of writing a loop in C++. Done
	// this way for expository purposes only.
	for (auto i = 0; i<100000000; i++) {
		// Cannot do j++ because pre/post increment
		// operations on volatile-qualified operations
		// are deprecated in C++20.
		int temp = j;
		temp++;
		j = temp;
	}
}
```

## The Experiment

The experiment was simple: Compile the code above and do an analysis of the generated assembly code.

The assembly code analyzed below is extracted from `episode3.obj` (`rustc` output) and `loop.obj` (`g++` output) which can be generated by running the `make obj` command in the `episode3` directory of the [IWTRIT](http://www.github.com/hawkinsw/iwtrit/) code.

## The Walkthrough

Line-by-line analysis of the assembly code is available in the `-annotated.obj` files in the `episode3` directory of the [IWTRIT](http://www.github.com/hawkinsw/iwtrit/) code.

### Rust

`rustc` in `release` mode generates the following code for the loop:
```
    5170:	83 04 24 01          	addl   $0x1,(%rsp)
    5174:	83 04 24 01          	addl   $0x1,(%rsp)
    5178:	83 04 24 01          	addl   $0x1,(%rsp)
    517c:	83 04 24 01          	addl   $0x1,(%rsp)
    5180:	83 04 24 01          	addl   $0x1,(%rsp)
    5184:	83 c0 fb             	add    $0xfffffffb,%eax
    5187:	75 e7                	jne    5170 <episode3::main+0x10>
```

Wait a second. In Rust we wrote a loop that specifies a single addition per iteration. However, the compiler generated a loop that performs 5 additions per iteration. What is going on?

The compiler is performing a common optimization known as loop unrolling. The compiler knows that the more branches the CPU has to execute (`jne` instructions in this case) the worse the performance of the program. In order to minimize that overhead, the compiler generates code that performs more than one iteration of the loop per branch. Counting the number of `addl` instructions, we can see that the compiler has unrolled the loop 5 fives.

The number of times the loop is unrolled changes the code that the compiler generates to keep track of when to stop looping. In this case, the compiler is using the register `%eax` to track when to stop looping. Before the body of the loop, the compiler fills the register with 100000000 (matching the Rust code) and the program loops as long as its value is non-zero (`jne 5170`).

Given that exposition, we would expect to see a `subl` somewhere in the code that the compiler generates. Yet, it isn't there! The compiler is optimizing again! The subtraction is actually disguised as an addition by a negative number. One of the forms of the `addl` instruction takes a signed integer as an argument. The literal `$0xfffffffb,` is such a signed integer and represents ... wait for it ... `-5`. Our subtraction is an add!


### C++

How does the code that `rustc` generates look compared to the code that `g++` generates. In order to compare apples-to-apples, we invoked `g++` with `O3` optimization levels. Here's what we got:

```
    113d:	ba 00 e1 f5 05       	mov    $0x5f5e100,%edx
    1142:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    1148:	8b 44 24 0c          	mov    0xc(%rsp),%eax
    114c:	83 c0 01             	add    $0x1,%eax
    114f:	89 44 24 0c          	mov    %eax,0xc(%rsp)
    1153:	48 83 ea 01          	sub    $0x1,%rdx
    1157:	75 ef                	jne    1148 <main+0x68>
```

First, some superficial differences:

1. The code is using `%rdx` not `%eax` to track when to stop looping.
2. The code is explicitly reading from memory, updating and writing to memory the value at every iteration rather than doing it implicitly. These memory operations are required by the way that the source code performs operations to conform to the C++ standard.

With the superficial differences noted, let's look at some more important differences.  First, the loop is not unrolled at all! Second, the subtraction is not disguised as an addition. Cats are dogs. Right is wrong.

Does this affect performance? Yes, it does. As mentioned above, the more branches a program asks the CPU to take, the worse the performance of the program. In the code generated by `rustc`, executing all 100000000 additions will require 100000000/5 branches. In the code generated by `g++`, executing all 100000000 additions will require 100000000 branches -- 5x more!

Can we get `g++` to generate better code? Yes! `g++` believes[^anthro] that unrolling a loop is not always in the user's best interest and does not enable it by default at any optimization level. The user has to specifically request loops be unrolled.

With the `-funroll-loops`, `g++` will perform loop unrolling.

```
    1098:	8b 44 24 fc          	mov    -0x4(%rsp),%eax
    109c:	83 c0 01             	add    $0x1,%eax
    109f:	89 44 24 fc          	mov    %eax,-0x4(%rsp)
    10a3:	8b 4c 24 fc          	mov    -0x4(%rsp),%ecx
    10a7:	83 c1 01             	add    $0x1,%ecx
    10aa:	89 4c 24 fc          	mov    %ecx,-0x4(%rsp)
    10ae:	8b 74 24 fc          	mov    -0x4(%rsp),%esi
    10b2:	83 c6 01             	add    $0x1,%esi
    10b5:	89 74 24 fc          	mov    %esi,-0x4(%rsp)
    10b9:	8b 7c 24 fc          	mov    -0x4(%rsp),%edi
    10bd:	83 c7 01             	add    $0x1,%edi
    10c0:	89 7c 24 fc          	mov    %edi,-0x4(%rsp)
    10c4:	44 8b 44 24 fc       	mov    -0x4(%rsp),%r8d
    10c9:	41 83 c0 01          	add    $0x1,%r8d
    10cd:	44 89 44 24 fc       	mov    %r8d,-0x4(%rsp)
    10d2:	44 8b 4c 24 fc       	mov    -0x4(%rsp),%r9d
    10d7:	41 83 c1 01          	add    $0x1,%r9d
    10db:	44 89 4c 24 fc       	mov    %r9d,-0x4(%rsp)
    10e0:	44 8b 54 24 fc       	mov    -0x4(%rsp),%r10d
    10e5:	41 83 c2 01          	add    $0x1,%r10d
    10e9:	44 89 54 24 fc       	mov    %r10d,-0x4(%rsp)
    10ee:	44 8b 5c 24 fc       	mov    -0x4(%rsp),%r11d
    10f3:	41 83 c3 01          	add    $0x1,%r11d
    10f7:	44 89 5c 24 fc       	mov    %r11d,-0x4(%rsp)
    10fc:	83 ea 08             	sub    $0x8,%edx
    10ff:	75 97                	jne    1098 <main+0x18>
```

By now, that code should look fairly familiar. For detailed analysis of the code, check out loop-annotated.obj in `episode3` folder of the [IWTRIT](http://www.github.com/hawkinsw/iwtrit/) code.

Count the number of `add` instructions to determine how many times the loop is unrolled. Find the instruction that decrements the counter variable. Does the number of times the loop is unrolled match the decrement?

## Questions

If you have any questions, please reach out at `whh8b@obs.cr`.

[^anthro]: yes, I anthropomorphized the compiler.
