# Episode 3

## The Premise

In this episode we continue from Episode 2 and dig deeper into the code generated by `rustc` for loops and compare that code with the code generated by a similar loop in C++.

In particular, we look at the code generated by `rust` for the loop in the following program:

```
use volatile::Volatile;

fn main() {
    let mut j = 0;
    let mut v = Volatile::new(&mut j);

    for _ in 0..1000000000 {
        v.write(v.read() + 1);
    }
}
```

and compare that with the code generated by `g++` for the following program:
```
#include <numeric>
#include <vector>

int main() {
	volatile int j = 0;
	std::vector<int> range(100000000);
	std::iota(range.begin(), range.end(), 0);

	for (auto i : range) {
		// Cannot do j++ because pre/post increment
		// operations on volatile-qualified operations
		// are deprecated in C++20.
		int temp = j;
		temp++;
		j = temp;
	}
}
```

## The Experiment

The assembly code shown below is extracted from `episode3.obj` (`rustc` output) and `loop.obj` (`g++` output) generated by running the `make obj` command in the `episode3` directory of the [IWTRIT](http://www.github.com/hawkinsw/iwtrit/) code.

## The Walkthrough

### Rust

`rustc` in `release` mode generates the following code for the loop:
```
    5170:	83 04 24 01          	addl   $0x1,(%rsp)
    5174:	83 04 24 01          	addl   $0x1,(%rsp)
    5178:	83 04 24 01          	addl   $0x1,(%rsp)
    517c:	83 04 24 01          	addl   $0x1,(%rsp)
    5180:	83 04 24 01          	addl   $0x1,(%rsp)
    5184:	83 c0 fb             	add    $0xfffffffb,%eax
    5187:	75 e7                	jne    5170 <episode3::main+0x10>
```

Wait a second. In Rust we wrote a loop that specifies a single addition per iteration. However, the compiler generated a loop that performs 5 additions per iteration. What is going on?

The compiler is performing a common optimization known as loop unrolling. The compiler knows that the more branches the CPU has to execute (`jne` instructions in this case) the worse the performance of the program. In order to minimize that overhead, the compiler generates code that performs more than one iteration of the loop per branch. Counting the number of `addl` instructions, we can see that the compiler has unrolled the loop 5 fives.

The number of times the loop is unrolled changes the code that the compiler generates to keep track of when to stop looping. In this case, the compiler is using the register `%eax` to track when to stop looping. Before the body of the loop, the compiler fills the register with 100000000 (matching the Rust code) and the program loops as long as its value is non-zero (`jne 5170`).

Given that exposition, we would expect to see a `subl` somewhere in the code that the compiler generates. Yet, it isn't there! The compiler is optimizing again! The subtraction is actually disguised as an addition by a negative number. One of the forms of the `addl` instruction takes a signed integer as an argument. The literal `$0xfffffffb,` is such a signed integer and represents ... wait for it ... `-5`. Our subtraction is an add!


### C++

How does the code that `rustc` generates look compared to the code that `gcc` generates. In order to compare apples-to-apples, we invoked `g++` with `O3` optimization levels. Here's what we got:

```
    113d:	ba 00 e1 f5 05       	mov    $0x5f5e100,%edx
    1142:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    1148:	8b 44 24 0c          	mov    0xc(%rsp),%eax
    114c:	83 c0 01             	add    $0x1,%eax
    114f:	89 44 24 0c          	mov    %eax,0xc(%rsp)
    1153:	48 83 ea 01          	sub    $0x1,%rdx
    1157:	75 ef                	jne    1148 <main+0x68>
```

First, some superficial differences. The code is using `%rdx` to track when to stop looping. The code is writing the value to memory at every iteration. These memory operations are required by the use of `volatile` in the C++ code. 

With the superficial differences noted, let's look at some more important differences.  First, the loop is not unrolled at all! Second, the subtraction is not disguised as an addition. Cats are dogs. Right is wrong.

Does this affect performance? Yes, it does. As mentioned above, the more branches a program asks the CPU to take, the worse the performance of the program. In the code generated by `rustc`, executing all 100000000 additions will require 100000000/5 branches. In the code generated by `g++`, executing all 100000000 additions will require 100000000 branches -- 5x more!

Can we get `g++` to generate better code? Yes! `g++` considers that unrolling a loop is not always in the user's best interest and does not enable it by default at any optimization level. The user has to specifically request loops be unrolled.

With the `-funroll-loops`, `g++` will perform loop unrolling.

```
    1195:	8b 74 24 0c          	mov    0xc(%rsp),%esi
    1199:	83 c6 01             	add    $0x1,%esi
    119c:	89 74 24 0c          	mov    %esi,0xc(%rsp)
    11a0:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
    11a5:	41 83 c0 01          	add    $0x1,%r8d
    11a9:	44 89 44 24 0c       	mov    %r8d,0xc(%rsp)
    11ae:	44 8b 4c 24 0c       	mov    0xc(%rsp),%r9d
    11b3:	41 83 c1 01          	add    $0x1,%r9d
    11b7:	44 89 4c 24 0c       	mov    %r9d,0xc(%rsp)
    11bc:	44 8b 54 24 0c       	mov    0xc(%rsp),%r10d
    11c1:	41 83 c2 01          	add    $0x1,%r10d
    11c5:	44 89 54 24 0c       	mov    %r10d,0xc(%rsp)
    11ca:	44 8b 5c 24 0c       	mov    0xc(%rsp),%r11d
    11cf:	41 83 c3 01          	add    $0x1,%r11d
    11d3:	44 89 5c 24 0c       	mov    %r11d,0xc(%rsp)
    11d8:	8b 44 24 0c          	mov    0xc(%rsp),%eax
    11dc:	83 c0 01             	add    $0x1,%eax
    11df:	89 44 24 0c          	mov    %eax,0xc(%rsp)
    11e3:	8b 54 24 0c          	mov    0xc(%rsp),%edx
    11e7:	83 c2 01             	add    $0x1,%edx
    11ea:	89 54 24 0c          	mov    %edx,0xc(%rsp)
    11ee:	8b 74 24 0c          	mov    0xc(%rsp),%esi
    11f2:	83 c6 01             	add    $0x1,%esi
    11f5:	89 74 24 0c          	mov    %esi,0xc(%rsp)
    11f9:	48 83 e9 08          	sub    $0x8,%rcx
    11fd:	75 96                	jne    1195 <main+0xb5>
```

By now, that code should look fairly familiar. Count the number of `add` instructions to determine how many times the loop is unrolled. Find the instruction that decrements the counter variable. Does the number of times the loop is unrolled match the decrement?
